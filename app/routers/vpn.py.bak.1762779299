# /home/ubuntu/homecam-api/app/routers/vpn.py
import os
import json
import base64
import time
from typing import Optional

import redis
from fastapi import APIRouter, HTTPException, Header
from pydantic import BaseModel, Field

from app.db import (
    init_db, upsert_vpn, fetch_assigned_ips, mark_vpn_removed,
    fetch_owner_user_id
)

# --- IPC (wgdaemon과 Unix 도메인 소켓 통신) ---
import socket as _sock
import json as _json

WG_SOCK_PATH = "/run/wgdaemon/wg.sock"

def _wg_ipc(action: str, payload: dict) -> None:
    req = {"action": action, **payload}
    data = _json.dumps(req).encode("utf-8")
    try:
        with _sock.socket(_sock.AF_UNIX, _sock.SOCK_STREAM) as s:
            s.connect(WG_SOCK_PATH)
            s.sendall(data)
            resp_raw = s.recv(4096)
    except Exception:
        raise HTTPException(status_code=502, detail="wg_ipc_unreachable")

    try:
        resp = _json.loads(resp_raw.decode("utf-8"))
    except Exception:
        raise HTTPException(status_code=502, detail="wg_ipc_bad_json")

    if not resp.get("ok"):
        err = resp.get("error", "wg_ipc_failed")
        raise HTTPException(status_code=502, detail=err)

# ── 초기화 ─────────────────────────────────────────────────────────────────────
init_db()
r = redis.Redis.from_url(os.getenv("REDIS_URL", "redis://localhost:6379/0"),
                         decode_responses=True)

# ✅ 라우터 선언 (모든 @router.* 데코레이터보다 위)
router = APIRouter(prefix="/vpn", tags=["vpn"])

# ── 서버/네트워크 기본값 ──────────────────────────────────────────────────────
SERVER_ENDPOINT = os.getenv("VPN_SERVER_ENDPOINT", "18.222.191.20:51820")
SERVER_WG_PUBKEY_B64 = os.getenv("VPN_SERVER_PUBKEY_B64", "SERVER_WG_PUBKEY_BASE64")
IP_NET = os.getenv("VPN_NET_PREFIX", "10.8.0.")
IP_START = int(os.getenv("VPN_IP_START_HOST", "2"))
IP_END = int(os.getenv("VPN_IP_END_HOST", "254"))

# ── 유틸 ───────────────────────────────────────────────────────────────────────
def _require_user(x_user_id: Optional[str]) -> int:
    if not x_user_id:
        raise HTTPException(status_code=401, detail="auth_required")
    try:
        return int(x_user_id)
    except Exception:
        raise HTTPException(status_code=400, detail="invalid_user_header")

def _b64url_decode(s: str) -> bytes:
    s_bytes = s.encode("ascii") if isinstance(s, str) else s
    s_bytes = s_bytes.replace(b"-", b"+").replace(b"_", b"/")
    s_bytes = s_bytes + b"=" * ((4 - (len(s_bytes) % 4)) % 4)
    return base64.b64decode(s_bytes)

def _verify_ed25519_b64url(pubkey_b64url: str, message: bytes, sig_b64url: str) -> bool:
    from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PublicKey
    from cryptography.exceptions import InvalidSignature
    try:
        pub_bytes = _b64url_decode(pubkey_b64url)
        sig_bytes = _b64url_decode(sig_b64url)
        Ed25519PublicKey.from_public_bytes(pub_bytes).verify(sig_bytes, message)
        return True
    except (InvalidSignature, ValueError, Exception):
        return False

def _alloc_ip(used: set[str]) -> str:
    used_hosts = {int(ip.split(".")[-1].split("/")[0]) for ip in used if ip.startswith(IP_NET)}
    for host in range(IP_START, IP_END + 1):
        cidr = f"{IP_NET}{host}/32"
        if host not in used_hosts and cidr not in used:
            return cidr
    raise HTTPException(status_code=503, detail="no_available_ip")

# ── JWT 등록 토큰 파서 ─────────────────────────────────────────────────────────
import jwt
REG_TOKEN_SECRET = os.getenv("REG_TOKEN_SECRET")

def _parse_registration_jwt(token: str) -> dict:
    try:
        if REG_TOKEN_SECRET:
            claims = jwt.decode(
                token,
                REG_TOKEN_SECRET,
                algorithms=["HS256"],
                options={"require": ["exp", "iat", "typ"]},
                leeway=300,
            )
        else:
            claims = jwt.decode(token, options={"verify_signature": False})
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="token_expired")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=400, detail="token_invalid")

    if claims.get("typ") != "registration":
        raise HTTPException(status_code=400, detail="token_typ_invalid")
    iss = claims.get("iss")
    if iss and iss not in ("ipcam", "homecam"):
        raise HTTPException(status_code=400, detail="token_iss_invalid")

    now = int(time.time())
    iat = int(claims.get("iat", 0))
    if iat > now + 300:
        raise HTTPException(status_code=400, detail="token_iat_invalid")
    return claims

# ── 스키마 ────────────────────────────────────────────────────────────────────
class BeCreateInfoBody(BaseModel):
    device_id: str = Field(min_length=3)
    device_pubkey_b64: str
    registration_token: str

class CreateTunnelBody(BaseModel):
    device_id: str
    timestamp: str
    registration_token: str
    signature_b64: str
    client_pubkey_b64: str

# ── 1) 터널 생성 예정 정보 저장 ────────────────────────────────────────────────
@router.post("/tunnels/be_create_info")
def be_create_info(body: BeCreateInfoBody, x_user_id: Optional[str] = Header(None)):
    user_id = _require_user(x_user_id)

    claims = _parse_registration_jwt(body.registration_token)
    now = int(time.time())
    ttl = int(claims["exp"]) - now
    if ttl <= 0:
        raise HTTPException(status_code=401, detail="token_expired")

    intent_key = f"vpn_intent:{body.device_id}"
    payload = {
        "device_id": body.device_id,
        "device_pubkey_b64": body.device_pubkey_b64,
        "registration_token": body.registration_token,
        "owner_user_id": user_id,
        "jti": claims.get("jti"),
        "iss": claims.get("iss"),
        "iat": claims.get("iat"),
        "exp": claims.get("exp"),
    }
    r.setex(intent_key, ttl, json.dumps(payload))
    return {"ok": True, "device_id": body.device_id, "ttl": ttl}

# ── 2) 터널 생성 ───────────────────────────────────────────────────────────────
@router.post("/tunnels/create")
def vpn_create(body: CreateTunnelBody, x_user_id: Optional[str] = Header(None)):
    user_id = _require_user(x_user_id)

    intent_key = f"vpn_intent:{body.device_id}"
    raw = r.get(intent_key)
    if not raw:
        raise HTTPException(status_code=404, detail="intent_not_found_or_expired")

    intent = json.loads(raw)
    token = intent.get("registration_token")
    device_pubkey_b64 = intent.get("device_pubkey_b64")
    owner_user_id = int(intent.get("owner_user_id") or user_id)

    if token != body.registration_token:
        raise HTTPException(status_code=400, detail="token_mismatch")
    _parse_registration_jwt(body.registration_token)

    msg = f"{body.device_id}|{body.timestamp}|{body.registration_token}".encode()
    if not _verify_ed25519_b64url(device_pubkey_b64, msg, body.signature_b64):
        raise HTTPException(status_code=400, detail="invalid_signature")

    used = fetch_assigned_ips()
    assigned_ip = _alloc_ip(used)
    allowed_ip = assigned_ip

    _wg_ipc("add_peer", {
        "device_id": body.device_id,
        "client_pubkey_b64": body.client_pubkey_b64,
        "ip_cidr": allowed_ip
    })

    upsert_vpn(
        device_id=body.device_id,
        owner_user_id=owner_user_id,
        client_pubkey=body.client_pubkey_b64,
        assigned_ip=assigned_ip,
        allowed_ip=allowed_ip,
        status="registered",
    )

    r.delete(intent_key)

    return {
        "device_id": body.device_id,
        "status": "registered",
        "tunnel": {
            "server_vpn_pubkey": SERVER_WG_PUBKEY_B64,
            "server_endpoint": SERVER_ENDPOINT,
            "allowed_ips": allowed_ip,
            "persistent_keepalive": 25,
        },
    }

# ── 3) 터널 삭제(204) ─────────────────────────────────────────────────────────
@router.delete("/tunnels/{device_id}", status_code=204)
def vpn_delete_tunnel(device_id: str, x_user_id: Optional[str] = Header(None)):
    user_id = _require_user(x_user_id)

    owner = fetch_owner_user_id(device_id)
    if owner is None:
        raise HTTPException(status_code=404, detail="not_found")
    if int(owner) != int(user_id):
        raise HTTPException(status_code=403, detail="forbidden")

    _wg_ipc("remove_peer", {"device_id": device_id})
    mark_vpn_removed(device_id)
    return
